package com.windows_kerberos.rest;

import com.windows_kerberos.auth.AuthenticationService;
import com.windows_kerberos.cache.UserCacheService;
import com.windows_kerberos.model.UserDetails;

import javax.inject.Inject;
import javax.ws.rs.*;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.SecurityContext;
import java.security.Principal;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

@Path("/auth")
public class AuthResource {
    private static final Logger LOGGER = Logger.getLogger(AuthResource.class.getName());
    
    @Inject
    private AuthenticationService authService;
    
    @Inject
    private UserCacheService cacheService;
    
 /**
 * Refreshes the current user's details by clearing cache and reloading from LDAP.
 */
@POST
@Path("/refresh")
@Produces(MediaType.APPLICATION_JSON)
public UserDetails refreshCurrentUser(@Context SecurityContext securityContext) {
    Principal principal = securityContext.getUserPrincipal();
    if (principal == null) {
        throw new NotAuthorizedException("Not authenticated");
    }
    
    String username = principal.getName();
    LOGGER.log(Level.INFO, "Refreshing details for user: {0}", username);
    
    return authService.refreshUserDetails(username);
}

/**
 * Admin endpoint to clear the entire user cache.
 */
@POST
@Path("/cache/clear")
@Produces(MediaType.APPLICATION_JSON)
public Response clearCache(@Context SecurityContext securityContext) {
    // In production, check if user has admin role
    
    if (cacheService.isCacheAvailable()) {
        cacheService.clearCache();
        return Response.ok("{\"success\": true, \"message\": \"Cache cleared\"}").build();
    } else {
        return Response.ok("{\"success\": false, \"message\": \"Cache not available\"}").build();
    }
}